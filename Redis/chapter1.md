## 基础与应用篇

### 概述

### 基础数据结构

#### string(字符串)

redis的字符串是动态字符串，是可以修改的字符串，内部结构实现类似 **java**的 **ArrayList**，采用**预分配冗余空间**的方式减少内存的频繁分配。

当字符串小于 1Mb时，扩容是 **加倍现有的空间**，如果字符串超过 1Mb时，扩容时每次只会多扩 **1Mb**的空间，字符串最大长度为 **512Mb**。

#### list(列表)

redis的list相当于 **java**的 **LinkedList**，是链表而不是数组，意味着 list的 **插入和删除** 操作很快，时间复杂度是O(1)，但索引定位很慢，是O(n)，列表中每个元素都使用 **双向指针顺序**，串起来可以支持前后向遍历。

list在redis底层存储不是简单的链表，而是叫做 **快速链表（quicklist）** 的一个结构。在列表元素较少的情况下，会使用一块 **连续的内存存储**，这个结构叫做 **压缩链表（ziplist）**，是将所有的元素彼此紧挨着一起存储，分配的事一块连续的内存。当数据量比较多的时候才会改成 **quicklist**。

普通链表需要附加 **指针空间**，浪费空间还会加重内存的碎片化，所以redis将 **链表** 和     **ziplist**结合起来组成了 **quicklist**，就是将多个 **ziplist**使用双指针串起来使用，既满足了快速的插入删除性能，又不会出现太大的冗余空间。

#### hash(字典)

redis的hash是无序字典，跟java的类似，也是 **数组 + 链表** 二维结构，当第一维hash发生碰撞时，就会将碰撞的元素用链表串接起来。

redis为了追求高性能，不能堵塞服务，采用了渐进式 **rehash** 策略。在 **rehash** 的同时，会保留新旧两个 **hash** 结构，查询会同时查询两个hash结构，在后续的定时任务以及hash操作中，循序渐进的将 **旧hash** 的内容迁移到 **新的hash**结构中。

#### set(集合)

相当于java的 **hashset**，内部键值对是无序的、唯一的

#### zset(有序集合)

一方面是一个set，保证了内部value的 **唯一性**，另一方面可以给每个value赋予一个 **score**，代表了这个value的排序权重，内部实现是一种 **跳跃列表** 的数据结构。

首先 zset要支持 **随机插入和删除**，因此不适合用数组表示，普通的链表结构按照score值进行排序，当有新元素需要插入时，要定位到特殊的插入点，才能继续保证链表时有序的。通常使用 **二分查找法** 来找到插入点，但是二分查找的对象必须是数组，链表做不到。

**跳表** 类似层级制，

### 分布式锁

### 延时队列

### 位图

### HyperLogLog

### 布隆过滤器

### 简单限流

### 漏斗限流

### GeoHash

### Scan

