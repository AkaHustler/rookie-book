## 基础与应用篇

### 1.1 概述

#### 1.11 基础数据结构

##### string(字符串)

redis的字符串是动态字符串，是可以修改的字符串，内部结构实现类似 **java**的 **ArrayList**，采用**预分配冗余空间**的方式减少内存的频繁分配。

当字符串小于 1Mb时，扩容是 **加倍现有的空间**，如果字符串超过 1Mb时，扩容时每次只会多扩 **1Mb**的空间，字符串最大长度为 **512Mb**。

##### list(列表)

redis的list相当于 **java**的 **LinkedList**，是链表而不是数组，意味着 list的 **插入和删除** 操作很快，时间复杂度是O(1)，但索引定位很慢，是O(n)，列表中每个元素都使用 **双向指针顺序**，串起来可以支持前后向遍历。

list在redis底层存储不是简单的链表，而是叫做 **快速链表（quicklist）** 的一个结构。在列表元素较少的情况下，会使用一块 **连续的内存存储**，这个结构叫做 **压缩链表（ziplist）**，是将所有的元素彼此紧挨着一起存储，分配的事一块连续的内存。当数据量比较多的时候才会改成 **quicklist**。

普通链表需要附加 **指针空间**，浪费空间还会加重内存的碎片化，所以redis将 **链表** 和     **ziplist**结合起来组成了 **quicklist**，就是将多个 **ziplist**使用双指针串起来使用，既满足了快速的插入删除性能，又不会出现太大的冗余空间。

##### hash(字典)

redis的hash是无序字典，跟java的类似，也是 **数组 + 链表** 二维结构，当第一维hash发生碰撞时，就会将碰撞的元素用链表串接起来。

redis为了追求高性能，不能堵塞服务，采用了渐进式 **rehash** 策略。在 **rehash** 的同时，会保留新旧两个 **hash** 结构，查询会同时查询两个hash结构，在后续的定时任务以及hash操作中，循序渐进的将 **旧hash** 的内容迁移到 **新的hash**结构中。

##### set(集合)

相当于java的 **hashset**，内部键值对是无序的、唯一的

##### zset(有序集合)

一方面是一个set，保证了内部value的 **唯一性**，另一方面可以给每个value赋予一个 **score**，代表了这个value的排序权重，内部实现是一种 **跳跃列表** 的数据结构。

首先 zset要支持 **随机插入和删除**，因此不适合用数组表示，普通的链表结构按照score值进行排序，当有新元素需要插入时，要定位到特殊的插入点，才能继续保证链表时有序的。通常使用 **二分查找法** 来找到插入点，但是二分查找的对象必须是数组，链表做不到。

**跳表** 类似层级制，最下面一层所有元素都会串起来，然后每隔几个元素挑选出一个代表，再将这几个代表使用另外一级指针串起来，再在这些代表里挑出二级代表串起来，以此类推。

为什么叫 “**跳表**”呢，是因为内部元素可能 “**身兼数职**”，元素可能同时处于L0，L1，L2层，在不同层次之间进行跳跃。定位插入点时，跳表采用一个 **随机策略** 来决定新元素可以兼职到第几层。位于 L0 层概率 100%，兼职到 L1 只有50%概率，L2 层只有25%，到 L3 层只有12.5%，以此类推，一直随机到最顶层 **L31层**。

**列表中的元素越多，能够深入的层次就越深，元素能进入到顶层的可能性就越大**。

#### 1.12 容器型数据结构通用规则

**list、set、hash、zset** 是容器型数据结构，遵循以下两条规则：

1. **create if not exists**：如果容器不存在，就创建一个
2. **drop if no elements**：如果容器元素没有了，就立即删除容器，释放内存个

### 1.2 分布式锁

**原子操作** 是指不会被线程调度机制打断的操作，这种操作一旦开始，就会运行到结束，中间不会有任何线程切换。

#### 1.2.1 分布式锁的奥义

**set lock:code true ex 5 nx**

**setnx** 和 **expire** 组合在一起的原子命令

可以通过以下修改让锁更加健壮：

- 

### 1.3 延时队列

### 1.4 位图

### 1.5 HyperLogLog

### 1.6 布隆过滤器

### 1.7 简单限流

### 1.8 漏斗限流

### 1.9 GeoHash

### 1.10 Scan

