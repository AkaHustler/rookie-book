## 基础与应用篇

### 1.1 概述

#### 1.11 基础数据结构

##### string(字符串)

redis的字符串是动态字符串，是可以修改的字符串，内部结构实现类似 **java**的 **ArrayList**，采用**预分配冗余空间**的方式减少内存的频繁分配。

当字符串小于 1Mb时，扩容是 **加倍现有的空间**，如果字符串超过 1Mb时，扩容时每次只会多扩 **1Mb**的空间，字符串最大长度为 **512Mb**。

##### list(列表)

redis的list相当于 **java**的 **LinkedList**，是链表而不是数组，意味着 list的 **插入和删除** 操作很快，时间复杂度是O(1)，但索引定位很慢，是O(n)，列表中每个元素都使用 **双向指针顺序**，串起来可以支持前后向遍历。

list在redis底层存储不是简单的链表，而是叫做 **快速链表（quicklist）** 的一个结构。在列表元素较少的情况下，会使用一块 **连续的内存存储**，这个结构叫做 **压缩链表（ziplist）**，是将所有的元素彼此紧挨着一起存储，分配的事一块连续的内存。当数据量比较多的时候才会改成 **quicklist**。

普通链表需要附加 **指针空间**，浪费空间还会加重内存的碎片化，所以redis将 **链表** 和     **ziplist**结合起来组成了 **quicklist**，就是将多个 **ziplist**使用双指针串起来使用，既满足了快速的插入删除性能，又不会出现太大的冗余空间。

##### hash(字典)

redis的hash是无序字典，跟java的类似，也是 **数组 + 链表** 二维结构，当第一维hash发生碰撞时，就会将碰撞的元素用链表串接起来。

redis为了追求高性能，不能堵塞服务，采用了渐进式 **rehash** 策略。在 **rehash** 的同时，会保留新旧两个 **hash** 结构，查询会同时查询两个hash结构，在后续的定时任务以及hash操作中，循序渐进的将 **旧hash** 的内容迁移到 **新的hash**结构中。

##### set(集合)

相当于java的 **hashset**，内部键值对是无序的、唯一的

##### zset(有序集合)

一方面是一个set，保证了内部value的 **唯一性**，另一方面可以给每个value赋予一个 **score**，代表了这个value的排序权重，内部实现是一种 **跳跃列表** 的数据结构。

首先 zset要支持 **随机插入和删除**，因此不适合用数组表示，普通的链表结构按照score值进行排序，当有新元素需要插入时，要定位到特殊的插入点，才能继续保证链表时有序的。通常使用 **二分查找法** 来找到插入点，但是二分查找的对象必须是数组，链表做不到。

**跳表** 类似层级制，最下面一层所有元素都会串起来，然后每隔几个元素挑选出一个代表，再将这几个代表使用另外一级指针串起来，再在这些代表里挑出二级代表串起来，以此类推。

为什么叫 “**跳表**”呢，是因为内部元素可能 “**身兼数职**”，元素可能同时处于L0，L1，L2层，在不同层次之间进行跳跃。定位插入点时，跳表采用一个 **随机策略** 来决定新元素可以兼职到第几层。位于 L0 层概率 100%，兼职到 L1 只有50%概率，L2 层只有25%，到 L3 层只有12.5%，以此类推，一直随机到最顶层 **L31层**。

**列表中的元素越多，能够深入的层次就越深，元素能进入到顶层的可能性就越大**。

#### 1.12 容器型数据结构通用规则

**list、set、hash、zset** 是容器型数据结构，遵循以下两条规则：

1. **create if not exists**：如果容器不存在，就创建一个
2. **drop if no elements**：如果容器元素没有了，就立即删除容器，释放内存个

### 1.2 分布式锁

**原子操作** 是指不会被线程调度机制打断的操作，这种操作一旦开始，就会运行到结束，中间不会有任何线程切换。

#### 1.2.1 分布式锁的奥义

**set lock:code true ex 5 nx**

**setnx** 和 **expire** 组合在一起的原子命令

#### 1.2.2 超时问题

redis分布式锁不能解决 **超时问题**，加锁与释放锁之间如果逻辑执行太长，以至于超出了锁的超时限制，就会出现问题。因此redis分布式锁不适用于较长时间的任务。

另外一个问题就是确保当前线程占有的锁不会被持有过期锁的进程释放

可以通过以下修改让锁更加健壮：

- 不适用固定的字符串作为键的值，而是设置一个不可猜测（**non-guessable**）的长随机字符串，作为口令串（**token**）
- 不使用 **del** 命令释放锁，而是发送一个lua脚本，这个脚本只在客户端传入的值和键的口令串相匹配时，才对键进行删除

这两个改动可以防止 **持有过期锁的客户端误删现有锁** 的情况出现

解锁脚本示例：

```lua
if redis.call("get",KEYS[1]) == ARGV[1]
then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

#### 1.3.3 可重入性

**可重入性** 指的就是线程在持有锁的情况再次请求加锁，如果一个锁支持 **同一个线程** 的 **多次加锁**，那这个锁就是可重入的。redis如果要支持可重入，需要对客户端的 **set** 方法进行包装

### 1.3 延时队列

redis的消息队列没有很多高级特性，没有ack保证，不适用于一些对于消息的可靠性有着极高要求的场景。

#### 1.3.1 异步消息队列

**list** 数据结构经常用于作为异步消息队列使用，用 **rpush和lpush** 入队列，用 **lpop和rpop** 出队列。

支持多个生产者和消费者并发进出消息，每个消费者拿到的消息都是不用的列表元素

#### 1.3.2 阻塞读

当队列空了的话，客户端会陷入 **pop** 的死循环，空轮询不但拉高客户端的cpu，还会拉高redis的 **Qps**，通常使用sleep解决这个问题。

睡眠会导致消息的延迟增大，如果有多个消费者，这个延迟会有所下降，有什么方法可以显著降低延迟呢？那就是 **blpop/brpop**，即 **阻塞读**。

阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来，消息的延迟几乎为0，使用 **blpop/brpop** 即可解决上述消息延迟问题。

#### 1.3.3 空闲链接自动断开

上述阻塞读还有个问题，如果线程一直阻塞在那里，redis的客户端连接就成了闲置连接，闲置过久的话，服务器会主动断开连接，阻塞读就会跑出异常，所以还是要客户端对异常进行处理。

#### 1.3.4 锁冲突处理

当客户端在处理请求时加锁没加成功的话一般有3种策略示例加锁失败：

1. 直接跑出异常，通知重试
2. sleep后重试
3. 将请求转移到延时队列，之后再重试

#### 1.3.5 延时队列的实现

延时队列通过 **zset** 实现，消息的到期处理时间作为score，用多个线程轮询到期的任务进行处理

### 1.4 位图

位图的内容就是普通的字符串，即 **byte数组**

### 1.5 HyperLogLog

HyperLogLog提供不精确的去重计数方案，标准误差是 **0.81%**，可以满足网站UV统计需求

### 1.6 布隆过滤器

布隆过滤器是判断元素是否存在，有一定的误判概率。判断某个元素是否存在时，当返回不存在，该元素可能存在，当返回不存在的时候，该元素一定不存在。

#### 1.6.1 布隆过滤器

每个布隆过滤器对应到redis的数据结构就是一个大型的位数组和几个不一样的 **无偏hash函数**，所谓无偏就是能把元素的 **hash值** 算得比较均匀，让元素被hash **映射到位数组中的位置比较随机**。

### 1.7 简单限流

### 1.8 漏斗限流

### 1.9 GeoHash

### 1.10 Scan
