## 第一章 前言

### 学习算法和刷题的思路指南

#### 数据结构的存储方式

**数据结构的存储方式只有两种：数组（顺序存储）、链表（链式存储）**

数组、链表是**结构基础**，其他数据结构从根本上都是在链表、数组上的特殊操作，只不过API不同。

**队列、栈** 这两种数据结构既可以使用链表也可以使用数组实现，用**数组**实现就要考虑 **扩容缩容** 的问题；用**链表**没有这个问题，但是需要 **更多的内存空间** 储存节点指针。

**图** 的两种表示方法，邻接表就是链表，邻接矩阵就是数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决问题，但是当图比较稀疏时很耗费空间；邻接表比较节省空间，但是在操作效率上比不过邻接矩阵。

**散列表** 是通过散列函数把键值映射到数组里。对于解决散列冲突的方法，**拉链法**需要链表特性，操作简单，但需要额外的空间存储指针；**线性探查法**需要数组特性，以便连续寻址，不需要指针的存储空间，但操作比较复杂

**树** 用数组实现就是 **堆**，因为堆是一个完全二叉树，用数组存储不需要节点指针，操作比较简单；用链表实现就是比较常见的 **树**，因为不一定是完全二叉树，所以不适合用数组存储。

**Redis**提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。

二者的优缺点如下：

**数组** 由于是紧凑连续存储，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度O(N)；如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度O(N)。

**链表** 因为元素不连续，是靠指针指向下一个元素的位置，不存在数组的扩容问题。如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入元素，时间复杂度O(1)。但是正是因为存储空间不连续，无法根据一个索引算出对应元素的地址，所以不能随机访问。而且由于每个元素必须存储前后元素位置的指针，会消耗相对更多的储存空间。